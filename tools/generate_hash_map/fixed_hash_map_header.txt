/**
 * AUTO GENERATED FILE
 *
 * This file contains the header for a hash map `{{ hash_map_name }}` which maps
 * `{{ key_type_name }}` keys to `{{ value_type_name }}` values.
 *
 * This hash map is designed for situations where you can set an upper bound on the
 * number of items you will have and that upper bound is still a reasonable amount of
 * memory. This represents the vast majority case, as most hash maps will never have more
 * than 100 items. Even in cases where the struct is quite large e.g. over a kilobyte, and
 * you have a large upper bound, say 100k, thats still ~100MB of data. This is an incredibly
 * rare case and you probably only have one of these in your program; this hash map would
 * still work for that case.
 *
 * This hash map is not suited for cases where the hash map will shrink and grow quite
 * substantially or there's no known upper bound. The most common example would be user
 * input that cannot reasonably be limited, e.g. a word processing application cannot simply
 * refuse to open very large (+10gig) documents. If you have some hash map which is built
 * from the document file then you need some other allocation strategy (you probably don't
 * want a normal hash map either as you'd be streaming things in and out of memory).
 *
 * This file was auto generated from the hash map generation utility that's part of
 * the "Jack's Standard Library" project. The utility generates a header file and a
 * C file for a type safe, open addressed, hash map. By generating the code rather
 * than using macros, two benefits are gained. One, the code is much easier to debug.
 * Two, it's much more obvious how much code you're generating, which means you are
 * much less likely to accidentally create the combinatoric explosion of code that's
 * so common in C++ projects. Adding friction to things is actually good sometimes.
 *
 * ## LICENSE
 *
 * Copyright (c) 2026 Jack Stouffer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software
 * is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * A hash map which maps `{{ key_type_name }}` keys to `{{ value_type_name }}` values.
 *
 * This hash map uses open addressing with linear probing. However, it never grows.
 * When initialized with the init function, all the memory this hash map will have
 * is allocated right away.
 */
typedef struct {{ hash_map_name }} {
    // putting the sentinel first means it's much more likely to get
    // corrupted from accidental overwrites, therefore making it
    // more likely that memory bugs are caught.
    uint32_t sentinel;
    uint32_t generational_id;
    JSLAllocatorInterface allocator;

    {% if key_is_str %}
    JSLImmutableMemory* keys_array;
    JSLStringLifeTime* key_lifetime_array;
    {% else %}
    {{ key_type_name }}* keys_array;
    {% endif %}

    {% if value_is_str %}
    JSLImmutableMemory* values_array;
    JSLStringLifeTime* value_lifetime_array;
    {% else %}
    {{ value_type_name }}* values_array;
    {% endif %}

    uint64_t* hashes_array;
    int64_t arrays_length;

    int64_t item_count;
    int64_t max_item_count;
    uint64_t seed;
} {{ hash_map_name }};

/**
 * Iterator type which is used by the iterator functions to
 * allow you to loop over the hash map contents.
 */
typedef struct {{ hash_map_name }}Iterator {
    {{ hash_map_name }}* hash_map;
    int64_t current_slot;
    uint64_t generational_id;
} {{ hash_map_name }}Iterator;

/**
 * Initialize an instance of the hash map.
 *
 * All of the memory that this hash map will need will be allocated from the passed in arena.
 * The hash map does not save a reference to the arena, but the arena memory must have the same
 * or greater lifetime than the hash map itself.
 *
 * @warning This hash map uses a well distributed hash. But in order to properly protect against
 * hash flooding attacks you must do two things. One, provide good random data for the
 * seed value. This means using your OS's secure random number generator, not `rand`.
 * As this is very platform specific JSL does not come with a mechanism for getting these
 * random numbers; you must do it yourself. Two, use a different seed value as often as
 * possible, ideally every user interaction. This would make hash flooding attacks almost
 * impossible. If you are absolutely sure that this hash map cannot be attacked with hash
 * flooding then zero is a valid seed value.
 *
 * @param hash_map The pointer to the hash map instance to initialize
 * @param allocator The allocator that this hash map will use
 * @param max_item_count The maximum amount of items this hash map can hold
 * @param seed Seed value for the hash function to protect against hash flooding attacks
 */
bool {{ function_prefix }}_init(
    {{ hash_map_name }}* hash_map,
    JSLAllocatorInterface allocator,
    int64_t max_item_count,
    uint64_t seed
);

/**
 * Insert the given value into the hash map. If the key already exists in 
 * the map the value will be overwritten. If the key type for this hash map
 * is a pointer, then a NULL key is a valid key type.
 *
 * @param hash_map The pointer to the hash map instance to initialize
 * @param key Hash map key
 * @param value Value to store
 * @returns A bool representing success or failure of insertion.
 */
bool {{ function_prefix }}_insert(
    {{ hash_map_name }}* hash_map,
    {% if key_is_str %}
    JSLImmutableMemory key,
    JSLStringLifeTime key_lifetime,
    {% else %}
    {{ key_type_name }} key,
    {% endif %}
    {% if value_is_str %}
    JSLImmutableMemory value,
    JSLStringLifeTime value_lifetime
    {% else %}
    {{ value_type_name }} value
    {% endif %}
);

/**
 * Get a value from the hash map if it exists. If it does not NULL is returned
 *
 * The pointer returned actually points to value stored inside of hash map.
 * You can change the value though the pointer.
 *
 * @param hash_map The pointer to the hash map instance to initialize
 * @param key Hash map key
 * @param value Value to store
 * @returns The pointer to the value in the hash map, or null.
 */
{% if value_is_str %}
JSLImmutableMemory {{ function_prefix }}_get(
{% else %}
{{ value_type_name }}* {{ function_prefix }}_get(
{% endif %}

    {{ hash_map_name }}* hash_map,
    {% if key_is_str %}
    JSLImmutableMemory key
    {% else %}
    {{ key_type_name }} key
    {% endif %}
);

/**
 * Remove a key/value pair from the hash map if it exists.
 * If it does not false is returned.
 *
 * This hash map uses backshift deletion instead of tombstones
 * due to the lack of rehashing. Deletion can be expensive in
 * medium sized maps.
 */
bool {{ function_prefix }}_delete(
    {{ hash_map_name }}* hash_map,
    {% if key_is_str %}
    JSLImmutableMemory key
    {% else %}
    {{ key_type_name }} key
    {% endif %}
);

/**
 * Free all the underlying memory that was allocated by this hash map on the given
 * allocator.
 */
void {{ function_prefix }}_free(
    {{ hash_map_name }}* hash_map
);

/**
 * Create a new iterator over this hash map.
 *
 * An iterator is a struct which holds enough state that it allows a loop to visit
 * each key/value pair in the hash map.
 *
 * Iterating over a hash map while modifying it does not have guaranteed
 * correctness. Any insertion or deletion after the iterator is created will
 * invalidate the iteration.
 *
 * Example usage:
 * @code
 * {{ key_type_name }} key;
 * {{ value_type_name }} value;
 * {{ hash_map_name }}Iterator iterator;
 * {{ function_prefix }}_iterator_start(hash_map, &iterator);
 * while ({{ function_prefix }}_iterator_next(&iterator, &key, &value))
 * {
 *     ...
 * }
 * @endcode
 */
bool {{ function_prefix }}_iterator_start(
    {{ hash_map_name }}* hash_map,
    {{ hash_map_name }}Iterator* iterator
);

/**
 * Iterate over the hash map. If a key/value was found then true is returned.
 *
 * Example usage:
 * @code
 * {{ key_type_name }} key;
 * {{ value_type_name }} value;
 * {{ hash_map_name }}Iterator iterator;
 * {{ function_prefix }}_iterator_start(hash_map, &iterator);
 * while ({{ function_prefix }}_iterator_next(&iterator, &key, &value))
 * {
 *     ...
 * }
 * @endcode
 */
bool {{ function_prefix }}_iterator_next(
    {{ hash_map_name }}Iterator* iterator,
    {% if key_is_str %}
    JSLImmutableMemory* out_key,
    {% else %}
    {{ key_type_name }}* out_key,
    {% endif %}
    {% if value_is_str %}
    JSLImmutableMemory* out_value
    {% else %}
    {{ value_type_name }}* out_value
    {% endif %}
);

