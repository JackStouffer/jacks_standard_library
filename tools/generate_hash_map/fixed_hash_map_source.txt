/**
 * AUTO GENERATED FILE
 *
 * See the header for more information.
 *
 * ## LICENSE
 *
 * Copyright (c) 2026 Jack Stouffer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software
 * is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

bool {{ function_prefix }}_init(
    {{ hash_map_name }}* hash_map,
    JSLAllocatorInterface allocator,
    int64_t max_item_count,
    uint64_t seed
)
{
    if (hash_map == NULL || max_item_count < 0)
        return false;

    JSL_MEMSET(hash_map, 0, sizeof({{ hash_map_name }}));

    hash_map->seed = seed;
    hash_map->allocator = allocator;
    hash_map->max_item_count = max_item_count;

    int64_t max_with_load_factor = (int64_t) ((float) max_item_count / 0.75f);

    hash_map->arrays_length = jsl_next_power_of_two_i64(max_with_load_factor);
    hash_map->arrays_length = JSL_MAX(hash_map->arrays_length, 32);

    {% if key_is_str %}
    hash_map->keys_array = (JSLImmutableMemory*) jsl_allocator_interface_alloc(
        allocator,
        ((int64_t) sizeof(JSLImmutableMemory)) * hash_map->arrays_length,
        JSL_DEFAULT_ALLOCATION_ALIGNMENT,
        false
    );
    if (hash_map->keys_array == NULL)
        return false;
    hash_map->key_lifetime_array = (JSLStringLifeTime*) jsl_allocator_interface_alloc(
        allocator,
        ((int64_t) sizeof(JSLStringLifeTime)) * hash_map->arrays_length,
        JSL_DEFAULT_ALLOCATION_ALIGNMENT,
        false
    );
    if (hash_map->key_lifetime_array == NULL)
        return false;
    {% else %}
    hash_map->keys_array = ({{ key_type_name }}*) jsl_allocator_interface_alloc(
        allocator,
        ((int64_t) sizeof({{ key_type_name }})) * hash_map->arrays_length,
        (int32_t) _Alignof({{ key_type_name }}),
        false
    );
    if (hash_map->keys_array == NULL)
        return false;
    {% endif %}


    {% if value_is_str %}
    hash_map->values_array = (JSLImmutableMemory*) jsl_allocator_interface_alloc(
        allocator,
        ((int64_t) sizeof(JSLImmutableMemory)) * hash_map->arrays_length,
        JSL_DEFAULT_ALLOCATION_ALIGNMENT,
        false
    );
    if (hash_map->values_array == NULL)
        return false;
    hash_map->value_lifetime_array = (JSLStringLifeTime*) jsl_allocator_interface_alloc(
        allocator,
        ((int64_t) sizeof(JSLStringLifeTime)) * hash_map->arrays_length,
        JSL_DEFAULT_ALLOCATION_ALIGNMENT,
        false
    );
    if (hash_map->value_lifetime_array == NULL)
        return false;
    {% else %}
    hash_map->values_array = ({{ value_type_name }}*) jsl_allocator_interface_alloc(
        allocator,
        ((int64_t) sizeof({{ value_type_name }})) * hash_map->arrays_length,
        (int32_t) _Alignof({{ value_type_name }}),
        false
    );
    if (hash_map->values_array == NULL)
        return false;
    {% endif %}

    hash_map->hashes_array = (uint64_t*) jsl_allocator_interface_alloc(
        allocator,
        ((int64_t) sizeof(uint64_t)) * hash_map->arrays_length,
        (int32_t) _Alignof(uint64_t),
        true
    );
    if (hash_map->hashes_array == NULL)
        return false;

    hash_map->sentinel = PRIVATE_SENTINEL_{{ hash_map_name }};
    return true;
}

static inline void {{ function_prefix }}_probe(
    {{ hash_map_name }}* hash_map,
    {% if key_is_str %}
    JSLImmutableMemory key,
    {% else %}
    {{ key_type_name }} key,
    {% endif %}
    int64_t* out_slot,
    uint64_t* out_hash,
    bool* out_found
)
{
    *out_slot = -1;
    *out_found = false;
    {{ hash_function }};

    // Avoid clashing with sentinel values
    if (*out_hash <= (uint64_t) JSL__HASHMAP_TOMBSTONE)
    {
        *out_hash = (uint64_t) JSL__HASHMAP_VALUE_OK;
    }

    int64_t total_checked = 0;
    uint64_t slot_mask = (uint64_t) hash_map->arrays_length - 1u;
    // Since our slot array length is always a pow 2, we can avoid a modulo
    int64_t slot = (int64_t) (*out_hash & slot_mask);

    while (total_checked < hash_map->arrays_length)
    {
        uint64_t slot_hash_value = hash_map->hashes_array[slot];

        if (slot_hash_value == JSL__HASHMAP_EMPTY)
        {
            *out_slot = slot;
            break;
        }

        if (slot_hash_value == *out_hash && {{ key_compare }})
        {
            *out_found = true;
            *out_slot = slot;
            break;
        }

        slot = (int64_t) (((uint64_t) slot + 1u) & slot_mask);
        ++total_checked;
    }

    if (total_checked >= hash_map->arrays_length)
    {
        *out_slot = -1;
    }
}

static inline void {{ function_prefix }}_backshift(
    {{ hash_map_name }}* hash_map,
    int64_t start_slot
)
{
    uint64_t slot_mask = (uint64_t) hash_map->arrays_length - 1u;

    int64_t hole = start_slot;
    int64_t current = (int64_t) (((uint64_t) start_slot + 1u) & slot_mask);

    int64_t loop_check = 0;
    while (loop_check < hash_map->arrays_length)
    {
        uint64_t hash_value = hash_map->hashes_array[current];

        if (hash_value == JSL__HASHMAP_EMPTY)
        {
            hash_map->hashes_array[hole] = JSL__HASHMAP_EMPTY;
            break;
        }

        int64_t ideal_slot = (int64_t) (hash_value & slot_mask);

        bool should_move = (current > hole)
            ? (ideal_slot <= hole || ideal_slot > current)
            : (ideal_slot <= hole && ideal_slot > current);

        if (should_move)
        {
            hash_map->keys_array[hole] = hash_map->keys_array[current];
            hash_map->values_array[hole] = hash_map->values_array[current];
            hash_map->hashes_array[hole] = hash_map->hashes_array[current];
            hole = current;
        }

        current = (int64_t) (((uint64_t) current + 1u) & slot_mask);

        ++loop_check;
    }
}

bool {{ function_prefix }}_insert(
    {{ hash_map_name }}* hash_map,
    {% if key_is_str %}
    JSLImmutableMemory key,
    JSLStringLifeTime key_lifetime,
    {% else %}
    {{ key_type_name }} key,
    {% endif %}
    {% if value_is_str %}
    JSLImmutableMemory value,
    JSLStringLifeTime value_lifetime
    {% else %}
    {{ value_type_name }} value
    {% endif %}
)
{
    bool insert_success = false;

    if (
        hash_map == NULL
        || hash_map->sentinel != PRIVATE_SENTINEL_{{ hash_map_name }}
        || hash_map->item_count >= hash_map->max_item_count
    )
        return insert_success;

    uint64_t hash = 0;
    int64_t slot = -1;
    bool existing_found = false;
    {{ function_prefix }}_probe(hash_map, key, &slot, &hash, &existing_found);

    // new key
    if (slot > -1 && !existing_found)
    {
        {% if key_is_str %}
        if (key_lifetime == JSL_STRING_LIFETIME_SHORTER)
            hash_map->keys_array[slot] = jsl_duplicate(hash_map->allocator, key);
        else
            hash_map->keys_array[slot] = key;

        hash_map->key_lifetime_array[slot] = key_lifetime;
        {% else %}
        hash_map->keys_array[slot] = key;
        {% endif %}

        {% if value_is_str %}
        if (value_lifetime == JSL_STRING_LIFETIME_SHORTER)
            hash_map->values_array[slot] = jsl_duplicate(hash_map->allocator, value);
        else
            hash_map->values_array[slot] = value;

        hash_map->value_lifetime_array[slot] = value_lifetime;
        {% else %}
        hash_map->values_array[slot] = value;
        {% endif %}

        hash_map->hashes_array[slot] = hash;
        ++hash_map->item_count;
        insert_success = true;
    }
    // update
    else if (slot > -1 && existing_found)
    {
        {% if value_is_str %}
        if (hash_map->value_lifetime_array[slot] == JSL_STRING_LIFETIME_SHORTER)
            jsl_allocator_interface_free(hash_map->allocator, hash_map->values_array[slot].data);

        if (value_lifetime == JSL_STRING_LIFETIME_SHORTER)
            hash_map->values_array[slot] = jsl_duplicate(hash_map->allocator, value);
        else
            hash_map->values_array[slot] = value;

        hash_map->value_lifetime_array[slot] = value_lifetime;
        {% else %}
        hash_map->values_array[slot] = value;
        {% endif %}

        insert_success = true;
    }

    if (insert_success)
    {
        ++hash_map->generational_id;
    }

    return insert_success;
}

{% if value_is_str %}
JSLImmutableMemory {{ function_prefix }}_get(
{% else %}
{{ value_type_name }}* {{ function_prefix }}_get(
{% endif %}

    {{ hash_map_name }}* hash_map,
    {% if key_is_str %}
    JSLImmutableMemory key
    {% else %}
    {{ key_type_name }} key
    {% endif %}
)
{
    {% if value_is_str %}
    JSLImmutableMemory res = {0};
    {% else %}
    {{ value_type_name }}* res = NULL;
    {% endif %}

    if (
        hash_map == NULL
        || hash_map->sentinel != PRIVATE_SENTINEL_{{ hash_map_name }}
        || hash_map->values_array == NULL
        || hash_map->keys_array == NULL
        || hash_map->hashes_array == NULL
    )
        return res;

    uint64_t hash = 0;
    int64_t slot = -1;
    bool existing_found = false;

    {{ function_prefix }}_probe(hash_map, key, &slot, &hash, &existing_found);
    
    if (slot > -1 && existing_found)
    {
        {% if value_is_str %}
        res = hash_map->values_array[slot];
        {% else %}
        res = &hash_map->values_array[slot];
        {% endif %}
    }

    return res;
}

bool {{ function_prefix }}_delete(
    {{ hash_map_name }}* hash_map,
    {% if key_is_str %}
    JSLImmutableMemory key
    {% else %}
    {{ key_type_name }} key
    {% endif %}
)
{
    bool success = false;

    if (
        hash_map == NULL
        || hash_map->sentinel != PRIVATE_SENTINEL_{{ hash_map_name }}
        || hash_map->values_array == NULL
        || hash_map->keys_array == NULL
        || hash_map->hashes_array == NULL
    )
        return success;

    uint64_t hash = 0;
    int64_t slot = -1;
    bool existing_found = false;
    {{ function_prefix }}_probe(hash_map, key, &slot, &hash, &existing_found);

    if (slot > -1 && existing_found)
    {
        {{ function_prefix }}_backshift(hash_map, slot);
        --hash_map->item_count;
        ++hash_map->generational_id;
        success = true;
    }

    return success;
}

void {{ function_prefix }}_free(
    {{ hash_map_name }}* hash_map
)
{
    if (
        hash_map == NULL
        || hash_map->sentinel != PRIVATE_SENTINEL_{{ hash_map_name }}
    )
        return;

    {% if key_is_str or value_is_str %}
    for (int64_t current_slot = 0; current_slot < hash_map->arrays_length; ++current_slot)
    {
        uint64_t hash_value = hash_map->hashes_array[current_slot];
        {% if key_is_str %}
        JSLStringLifeTime lifetime = hash_map->key_lifetime_array[current_slot];
        if (hash_value != JSL__HASHMAP_EMPTY && lifetime == JSL_STRING_LIFETIME_SHORTER)
        {
            jsl_allocator_interface_free(hash_map->allocator, hash_map->keys_array[current_slot].data);
        }
        {% elif value_is_str %}
        JSLStringLifeTime lifetime = hash_map->value_lifetime_array[current_slot];
        if (hash_value != JSL__HASHMAP_EMPTY && lifetime == JSL_STRING_LIFETIME_SHORTER)
        {
            jsl_allocator_interface_free(hash_map->allocator, hash_map->values_array[current_slot].data);
        }
        {% endif %}
    }

    {% if key_is_str %}
    jsl_allocator_interface_free(hash_map->allocator, hash_map->key_lifetime_array);
    {% elif value_is_str %}
    jsl_allocator_interface_free(hash_map->allocator, hash_map->value_lifetime_array);
    {% endif %}

    {% endif %}

    jsl_allocator_interface_free(hash_map->allocator, hash_map->keys_array);
    jsl_allocator_interface_free(hash_map->allocator, hash_map->values_array);
    jsl_allocator_interface_free(hash_map->allocator, hash_map->hashes_array);
}

bool {{ function_prefix }}_iterator_start(
    {{ hash_map_name }}* hash_map,
    {{ hash_map_name }}Iterator* iterator
)
{
    if (
        hash_map == NULL
        || hash_map->sentinel != PRIVATE_SENTINEL_{{ hash_map_name }}
    )
        return false;

    iterator->hash_map = hash_map;
    iterator->current_slot = 0;
    iterator->generational_id = hash_map->generational_id;

    return true;
}

bool {{ function_prefix }}_iterator_next(
    {{ hash_map_name }}Iterator* iterator,
    {% if key_is_str %}
    JSLImmutableMemory* out_key,
    {% else %}
    {{ key_type_name }}* out_key,
    {% endif %}
    {% if value_is_str %}
    JSLImmutableMemory* out_value
    {% else %}
    {{ value_type_name }}* out_value
    {% endif %}
)
{
    bool found = false;

    if (
        iterator == NULL
        || iterator->hash_map == NULL
        || iterator->hash_map->sentinel != PRIVATE_SENTINEL_{{ hash_map_name }}
        || iterator->hash_map->generational_id != iterator->generational_id
        || iterator->hash_map->values_array == NULL
        || iterator->hash_map->keys_array == NULL
        || iterator->hash_map->hashes_array == NULL
    )
        return found;

    int64_t found_entry = -1;

    while (iterator->current_slot < iterator->hash_map->arrays_length)
    {
        uint64_t hash_value = iterator->hash_map->hashes_array[iterator->current_slot];

        bool occupied = hash_value != JSL__HASHMAP_EMPTY;

        if (occupied)
        {
            found_entry = iterator->current_slot;
            break;
        }
        else
        {
            ++iterator->current_slot;
        }
    }

    if (found_entry > -1)
    {
        *out_key = iterator->hash_map->keys_array[iterator->current_slot];
        *out_value = iterator->hash_map->values_array[iterator->current_slot];
        ++iterator->current_slot;
        found = true;
    }
    else
    {
        iterator->current_slot = iterator->hash_map->arrays_length;
        found = false;
    }

    return found;
}
