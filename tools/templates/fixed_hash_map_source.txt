/**
 * AUTO GENERATED FILE
 *
 * This file contains the source for a hash map `{{ hash_map_name }}` which maps
 * `{{ key_type_name }}` keys to `{{ value_type_name }}` values.
 *
 * This file was auto generated from the hash map generation utility that's part of
 * the "Jack's Standard Library" project. The utility generates a header file and a
 * C file for a type safe, open addressed, linear probed, hash map. By generating
 * the code rather than using macros, two benefits are gained. One, the code is much
 * easier to debug. Two, it's much more obvious how much code you're generating,
 * which means you are much less likely to accidentally create the combinatoric
 * explosion of code that's so common in C++ projects. Sometimes, adding friction
 * to things is good.
 *
 * Much like the arena allocator it uses, this hash map is designed for situations where
 * you can set an upper bound on the number of items you will have and that upper bound is
 * still a reasonable amount of memory. This represents the vast majority case, as most hash
 * maps will never have more than 100 items. Even in cases where the struct is quite large
 * e.g. over a kilobyte, and you have a large upper bound, say 100k, thats still ~100MB of
 * data. This is an incredibly rare case and you probably only have one of these in your
 * program; this hash map would still work for that case.
 *
 * This hash map is not suited for cases where the hash map will shrink and grow quite
 * substantially or there's no known upper bound. The most common example would be user
 * input that cannot reasonably be limited, e.g. a word processing application cannot simply
 * refuse to open very large (+10gig) documents. If you have some hash map which is built
 * from the document file then you need some other allocation strategy (you probably don't
 * want a normal hash map either as you'd be streaming things in and out of memory).
 */

bool {{ function_prefix }}_init(
    {{ hash_map_name }}* hash_map,
    JSLArena* arena,
    int64_t max_item_count,
    uint64_t seed
)
{
    JSL_MEMSET(hash_map, 0, sizeof({{ hash_map_name }}));

    if (hash_map == NULL || arena == NULL || max_item_count < 0)
        return false;

    hash_map->seed = seed;
    hash_map->max_item_count = max_item_count;
    hash_map->arrays_length = (int64_t) jsl_next_power_of_two_u64((uint64_t) (max_item_count + 2));
    hash_map->arrays_length = JSL_MAX(hash_map->arrays_length, 32);

    hash_map->keys_array = ({{ key_type_name }}*) jsl_arena_allocate_aligned(
       arena,
       ((int64_t) sizeof({{ key_type_name }})) * hash_map->arrays_length,
       (int32_t) _Alignof({{ key_type_name }}),
       false
    ).data;
    if (hash_map->keys_array == NULL)
        return false;

    hash_map->values_array = ({{ value_type_name }}*) jsl_arena_allocate_aligned(
        arena,
        ((int64_t) sizeof({{ value_type_name }})) * hash_map->arrays_length,
        (int32_t) _Alignof({{ value_type_name }}),
        false
    ).data;
    if (hash_map->values_array == NULL)
        return false;

    hash_map->hashes_array = (uint64_t*) jsl_arena_allocate_aligned(
        arena,
        ((int64_t) sizeof(uint64_t)) * hash_map->arrays_length,
        (int32_t) _Alignof(uint64_t),
        true
    ).data;
    if (hash_map->hashes_array == NULL)
        return false;

    hash_map->sentinel = PRIVATE_SENTINEL_{{ hash_map_name }};
    return true;
}

static inline void {{ function_prefix }}_probe(
    {{ hash_map_name }}* hash_map,
    {{ key_type_name }} key,
    int64_t* out_slot,
    uint64_t* out_hash,
    bool* out_found
)
{
    *out_slot = -1;
    *out_found = false;

    int64_t first_tombstone = -1;
    bool tombstone_seen = false;

    {{ hash_function }};

    // Avoid clashing with empty/tombstone sentinels
    if (*out_hash <= (uint64_t) JSL__HASHMAP_TOMBSTONE)
    {
        *out_hash = (uint64_t) JSL__HASHMAP_VALUE_OK;
    }

    int64_t total_checked = 0;
    uint64_t slot_mask = (uint64_t) hash_map->arrays_length - 1u;
    // Since our slot array length is always a pow 2, we can avoid a modulo
    int64_t slot = (int64_t) (*out_hash & slot_mask);

    while (total_checked < hash_map->arrays_length)
    {
        uint64_t slot_hash_value = hash_map->hashes_array[slot];

        bool is_empty = slot_hash_value == JSL__HASHMAP_EMPTY;
        bool is_tombstone = slot_hash_value == JSL__HASHMAP_TOMBSTONE;

        if (is_empty)
        {
            *out_slot = tombstone_seen ? first_tombstone : slot;
            break;
        }

        if (is_tombstone && !tombstone_seen)
        {
            first_tombstone = slot;
            tombstone_seen = true;
        }

        bool slot_has_value = !is_empty && !is_tombstone;
        bool matches = slot_has_value
            && *out_hash == slot_hash_value
            && JSL_MEMCMP(&key, &hash_map->keys_array[slot], sizeof({{ key_type_name }})) == 0;

        if (matches)
        {
            *out_found = true;
            *out_slot = slot;
            break;
        }

        if (!slot_has_value)
        {
            hash_map->hashes_array[slot] = JSL__HASHMAP_TOMBSTONE;
        }

        if (!slot_has_value && !tombstone_seen)
        {
            first_tombstone = slot;
            tombstone_seen = true;
        }

        slot = (int64_t) (((uint64_t) slot + 1u) & slot_mask);
        ++total_checked;
    }

    if (total_checked >= hash_map->arrays_length)
    {
        *out_slot = tombstone_seen ? first_tombstone : -1;
    }
}

bool {{ function_prefix }}_insert(
    {{ hash_map_name }}* hash_map,
    {{ key_type_name }} key,
    {{ value_type_name }} value
)
{
    bool insert_success = false;

    if (
        hash_map == NULL
        || hash_map->sentinel != PRIVATE_SENTINEL_{{ hash_map_name }}
        || hash_map->values_array == NULL
        || hash_map->keys_array == NULL
        || hash_map->hashes_array == NULL
        || hash_map->item_count >= hash_map->max_item_count
    )
        return insert_success;

    uint64_t hash = 0;
    int64_t slot = -1;
    bool existing_found = false;
    {{ function_prefix }}_probe(hash_map, key, &slot, &hash, &existing_found);

    // new key
    if (slot > -1 && !existing_found)
    {
        hash_map->keys_array[slot] = key;
        hash_map->values_array[slot] = value;
        hash_map->hashes_array[slot] = hash;
        ++hash_map->item_count;
        insert_success = true;
    }
    // update
    else if (slot > -1 && existing_found)
    {
        hash_map->values_array[slot] = value;
        insert_success = true;
    }

    if (insert_success)
    {
        ++hash_map->generational_id;
    }

    return insert_success;
}

{{ value_type_name }}* {{ function_prefix }}_get(
    {{ hash_map_name }}* hash_map,
    {{ key_type_name }} key
)
{
    {{ value_type_name }}* res = NULL;

    if (
        hash_map == NULL
        || hash_map->sentinel != PRIVATE_SENTINEL_{{ hash_map_name }}
        || hash_map->values_array == NULL
        || hash_map->keys_array == NULL
        || hash_map->hashes_array == NULL
    )
        return res;

    uint64_t hash = 0;
    int64_t slot = -1;
    bool existing_found = false;
    {{ function_prefix }}_probe(hash_map, key, &slot, &hash, &existing_found);
    
    if (slot > -1 && existing_found)
    {
        res = &hash_map->values_array[slot];
    }

    return res;
}

bool {{ function_prefix }}_delete(
    {{ hash_map_name }}* hash_map,
    {{ key_type_name }} key
)
{
    bool success = false;

    if (
        hash_map == NULL
        || hash_map->sentinel != PRIVATE_SENTINEL_{{ hash_map_name }}
        || hash_map->values_array == NULL
        || hash_map->keys_array == NULL
        || hash_map->hashes_array == NULL
    )
        return success;

    uint64_t hash = 0;
    int64_t slot = -1;
    bool existing_found = false;
    {{ function_prefix }}_probe(hash_map, key, &slot, &hash, &existing_found);

    if (slot > -1 && existing_found)
    {
        hash_map->hashes_array[slot] = JSL__HASHMAP_TOMBSTONE;
        --hash_map->item_count;
        success = true;
    }

    return success;
}

bool {{ function_prefix }}_iterator_start(
    {{ hash_map_name }}* hash_map,
    {{ hash_map_name }}Iterator* iterator
)
{
    bool success = false;

    if (
        hash_map == NULL
        || hash_map->sentinel != PRIVATE_SENTINEL_{{ hash_map_name }}
        || hash_map->values_array == NULL
        || hash_map->keys_array == NULL
        || hash_map->hashes_array == NULL
    )
        return success;

    iterator->hash_map = hash_map;
    iterator->current_slot = 0;
    iterator->generational_id = hash_map->generational_id;

    return iterator;
}

bool {{ function_prefix }}_iterator_next(
    {{ hash_map_name }}Iterator* iterator,
    {{ key_type_name }}* out_key,
    {{ value_type_name }}* out_value
)
{
    bool found = false;

    if (
        iterator == NULL
        || iterator->hash_map == NULL
        || iterator->hash_map->sentinel != PRIVATE_SENTINEL_{{ hash_map_name }}
        || iterator->hash_map->generational_id != iterator->generational_id
        || iterator->hash_map->values_array == NULL
        || iterator->hash_map->keys_array == NULL
        || iterator->hash_map->hashes_array == NULL
    )
        return found;

    int64_t found_entry = -1;

    while (iterator->current_slot < iterator->hash_map->arrays_length)
    {
        uint64_t hash_value = iterator->hash_map->hashes_array[iterator->current_slot];

        bool occupied = hash_value != JSL__HASHMAP_EMPTY
            && hash_value != JSL__HASHMAP_TOMBSTONE;

        if (occupied)
        {
            found_entry = iterator->current_slot;
            break;
        }
        else
        {
            ++iterator->current_slot;
        }
    }

    if (found_entry > -1)
    {
        *out_key = iterator->hash_map->keys_array[iterator->current_slot];
        *out_value = iterator->hash_map->values_array[iterator->current_slot];
        ++iterator->current_slot;
        found = true;
    }
    else
    {
        iterator->current_slot = iterator->hash_map->arrays_length;
        found = false;
    }

    return found;
}
