/**
 * AUTO GENERATED FILE
 *
 * This file contains the source for a hash map `{{ hash_map_name }}` which maps
 * `{{ key_type_name }}` keys to `{{ value_type_name }}` values.
 *
 * This file was auto generated from the hash map generation utility that's part of
 * the "Jack's Standard Library" project. The utility generates a header file and a
 * C file for a type safe, open addressed, hash map. By generating the code rather
 * than using macros, two benefits are gained. One, the code is much easier to debug.
 * Two, it's much more obvious how much code you're generating, which means you are
 * much less likely to accidentally create the combinatoric explosion of code that's
 * so common in C++ projects. Adding friction to things is actually good sometimes.
 *
 * Much like the arena allocator it uses, this hash map is designed for situations where
 * you can set an upper bound on the number of items you will have and that upper bound is
 * still a reasonable amount of memory. This represents the vast majority case, as most hash
 * maps will never have more than 100 items. Even in cases where the struct is quite large
 * e.g. over a kilobyte, and you have a large upper bound, say 100k, thats still ~100MB of
 * data. This is an incredibly rare case and you probably only have one of these in your
 * program; this hash map would still work for that case.
 *
 * This hash map is not suited for cases where the hash map will shrink and grow quite
 * substantially or there's no known upper bound. The most common example would be user
 * input that cannot reasonably be limited, e.g. a word processing application cannot simply
 * refuse to open very large (+10gig) documents. If you have some hash map which is built
 * from the document file then you need some other allocation strategy (you probably don't
 * want a normal hash map either as you'd be streaming things in and out of memory).
 */

bool {{ function_prefix }}_init(
    {{ hash_map_name }}* hash_map,
    JSLArena* arena,
    int64_t max_item_count,
    uint64_t seed
)
{
    JSL_MEMSET(hash_map, 0, sizeof({{ hash_map_name }}));

    if (hash_map == NULL || arena == NULL || max_item_count < 0)
        return false;

    hash_map->seed = seed;
    hash_map->max_item_count = max_item_count;
    hash_map->arrays_length = (int64_t) jsl_next_power_of_two_u64((uint64_t) (max_item_count + 2));
    hash_map->arrays_length = JSL_MAX(hash_map->arrays_length, 32);

    hash_map->keys_array = ({{ key_type_name }}*) jsl_arena_allocate_aligned(
       arena,
       ((int64_t) sizeof({{ key_type_name }})) * hash_map->arrays_length,
       (int32_t) _Alignof({{ key_type_name }}),
       false
    ).data;
    if (hash_map->keys_array == NULL)
        return false;

    hash_map->values_array = ({{ value_type_name }}*) jsl_arena_allocate_aligned(
        arena,
        ((int64_t) sizeof({{ value_type_name }})) * hash_map->arrays_length,
        (int32_t) _Alignof({{ value_type_name }}),
        false
    ).data;
    if (hash_map->values_array == NULL)
        return false;

    hash_map->hashes_array = (uint64_t*) jsl_arena_allocate_aligned(
        arena,
        ((int64_t) sizeof(uint64_t)) * hash_map->arrays_length,
        (int32_t) _Alignof(uint64_t),
        false
    ).data;
    if (hash_map->hashes_array == NULL)
        return false;

    return true;
}

static inline void {{ function_prefix }}_probe(
    {{ hash_map_name }}* hash_map,
    {{ key_type_name }} key,
    int64_t* out_slot,
    uint64_t* out_hash,
    bool* out_found
)
{
    *out_slot = -1;
    *out_found = false;

    int64_t first_tombstone = -1;
    bool tombstone_seen = false;
    bool searching = true;

    {{ hash_function }};

    int64_t total_checked = 0;
    // Since our slot array length is always a pow 2, we can avoid a modulo
    int64_t slot = (int64_t) (*out_hash & ((uint64_t) hash_map->arrays_length - 1u));

    while (total_checked < hash_map->arrays_length)
    {
        uint64_t slot_hash = hash_map->hashes_array[slot];

        bool is_empty = slot_hash == JSL__HASHMAP_EMPTY;
        bool is_tombstone = slot_hash == JSL__HASHMAP_TOMBSTONE;

        if (is_slot_set == 0 && is_insert)
        {
            return_value.value_index = slot_index;
            return_value.is_update = false;
            break;
        }
        /* Updating value */
        else if (is_slot_set == 1)
        {
            int32_t memcmp_res = JSL_MEMCMP(
                &hash_map->keys_array[slot_index],
                &key,
                sizeof({{ key_type_name }})
            );
            if (memcmp_res == 0)
            {
                return_value.value_index = slot_index;
                return_value.is_update = true;
                break;
            }
        }

        // Collision. Move to the next spot with linear probing

        ++total_checked;
        ++slot_index;


        // Loop all the way back around
        if (slot_index == hash_map->arrays_length)
        {
            slot_index = 0;
            return_value.is_set_array_bit = 0;
            return_value.is_set_array_index = 0;
        }
    }

    return return_value;
}

bool {{ function_prefix }}_insert(
    {{ hash_map_name }}* hash_map,
    {{ key_type_name }} key,
    {{ value_type_name }} value
)
{
    bool insert_success = false;

    if (
        hash_map == NULL
        || hash_map->values_array == NULL
        || hash_map->keys_array == NULL
        || hash_map->is_set_flags_array == NULL
        || hash_map->item_count == hash_map->max_item_count
    )
        return insert_success;

    if (hash_map->item_count == hash_map->arrays_length)
    {
        return insert_success;
    }

    struct {{ hash_map_name }}FindRes find_res = {{ function_prefix }}_hash_and_find_slot(
        hash_map,
        key,
        true
    );
    if (find_res.value_index != -1)
    {
        if (find_res.is_update)
        {
            hash_map->values_array[find_res.value_index] = value;
            insert_success = true;
        }
        else
        {
            hash_map->keys_array[find_res.value_index] = key;
            hash_map->values_array[find_res.value_index] = value;
            uint32_t bit_flag = JSL_MAKE_BITFLAG(find_res.is_set_array_bit);
            JSL_SET_BITFLAG(
                &hash_map->is_set_flags_array[find_res.is_set_array_index],
                bit_flag
            );
            ++hash_map->item_count;
            insert_success = true;
        }

        ++hash_map->generational_id;
    }

    return insert_success;
}

{{ value_type_name }}* {{ function_prefix }}_get(
    {{ hash_map_name }}* hash_map,
    {{ key_type_name }} key
)
{
    {{ value_type_name }}* res = NULL;

    if (
        hash_map == NULL
        || hash_map->values_array == NULL
        || hash_map->keys_array == NULL
        || hash_map->is_set_flags_array == NULL
    )
        return res;

    struct {{ hash_map_name }}FindRes find_res = {{ function_prefix }}_hash_and_find_slot(hash_map, key, false);
    if (find_res.value_index != -1 && find_res.is_update)
    {
        res = &hash_map->values_array[find_res.value_index];
    }

    return res;
}

bool {{ function_prefix }}_delete(
    {{ hash_map_name }}* hash_map,
    {{ key_type_name }} key
)
{
    bool success = false;

    if (
        hash_map == NULL
        || hash_map->values_array == NULL
        || hash_map->keys_array == NULL
        || hash_map->is_set_flags_array == NULL
    )
        return success;

    struct {{ hash_map_name }}FindRes find_res = {{ function_prefix }}_hash_and_find_slot(hash_map, key, false);

    if (find_res.value_index != -1 && find_res.is_update)
    {
        uint32_t bit_flag = JSL_MAKE_BITFLAG(find_res.is_set_array_bit);
        JSL_UNSET_BITFLAG(
            &hash_map->is_set_flags_array[find_res.is_set_array_index],
            bit_flag
        );
        --hash_map->item_count;
        success = true;
    }

    return success;
}

bool {{ function_prefix }}_iterator_start(
    {{ hash_map_name }}* hash_map,
    {{ hash_map_name }}Iterator* iterator
)
{
    bool success = false;

    if (
        hash_map == NULL
        || hash_map->values_array == NULL
        || hash_map->keys_array == NULL
        || hash_map->is_set_flags_array == NULL
    )
        return success;

    iterator->hash_map = hash_map;
    iterator->current_slot_index = 0;
    iterator->generational_id = hash_map->generational_id;

    return iterator;
}

bool {{ function_prefix }}_iterator_next(
    {{ hash_map_name }}Iterator* iterator,
    {{ key_type_name }}* key,
    {{ value_type_name }}* value
)
{
    bool result = false;

    if (
        iterator == NULL
        || iterator->hash_map == NULL
        || iterator->hash_map->values_array == NULL
        || iterator->hash_map->keys_array == NULL
        || iterator->hash_map->is_set_flags_array == NULL
    )
        return result;

    while (iterator->current_slot_index < iterator->hash_map->arrays_length)
    {
        int64_t is_set_flags_index = JSL__HASH_MAP_GET_SET_FLAG_INDEX(iterator->current_slot_index);
        uint32_t is_set_flags = iterator->hash_map->is_set_flags_array[is_set_flags_index];
        bool at_start_of_flags = (iterator->current_slot_index & 31) == 0;  // modulo 32

        if (at_start_of_flags && is_set_flags == 0)
        {
            iterator->current_slot_index += 32;
        }
        else if (at_start_of_flags)
        {
            iterator->current_slot_index += JSL_PLATFORM_COUNT_TRAILING_ZEROS(is_set_flags);

            *key = iterator->hash_map->keys_array[iterator->current_slot_index];
            *value = iterator->hash_map->values_array[iterator->current_slot_index];

            ++iterator->current_slot_index;
            result = true;
            break;
        }
        else
        {
            uint32_t current_is_set_flags_bit = (uint32_t) (iterator->current_slot_index - (is_set_flags_index * 32));
            uint32_t bitflag = JSL_MAKE_BITFLAG(current_is_set_flags_bit);
            bool is_set = JSL_IS_BITFLAG_SET(is_set_flags, bitflag);

            if (is_set)
            {
                *key = iterator->hash_map->keys_array[iterator->current_slot_index];
                *value = iterator->hash_map->values_array[iterator->current_slot_index];

                ++iterator->current_slot_index;
                result = true;
                break;
            }
            else
            {
                ++iterator->current_slot_index;
            }
        }
    }

    return result;
}
